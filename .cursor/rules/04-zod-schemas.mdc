# Zod Schema Design for MCP Servers

## Schema-First Development

Zod schemas are the foundation of your MCP server. They define data validation, type safety, and AI agent understanding.

## Basic Schema Patterns

### Simple Entity Schema
```typescript
const TaskSchema = z.object({
  id: z.string().readonly(),           // Auto-generated, read-only
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  status: z.enum(["pending", "in_progress", "completed"]).default("pending"),
  priority: z.enum(["low", "medium", "high"]).default("medium"),
  createdAt: z.date().readonly(),      // Auto-set, read-only
  updatedAt: z.date().readonly(),      // Auto-updated, read-only
});

type Task = z.infer<typeof TaskSchema>;
```

### Complex Nested Schema
```typescript
const ProjectSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  status: z.enum(["active", "paused", "completed", "cancelled"]).default("active"),
  metadata: z.object({
    startDate: z.date().optional(),
    endDate: z.date().optional(),
    budget: z.number().positive().optional(),
    tags: z.array(z.string()).default([]),
  }).default({}),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

const TaskSchema = z.object({
  id: z.string().readonly(),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  projectId: z.string().min(1, "Project is required"),
  status: z.enum(["pending", "in_progress", "completed"]).default("pending"),
  priority: z.enum(["low", "medium", "high"]).default("medium"),
  tags: z.array(z.string()).default([]),
  dueDate: z.date().optional(),
  estimatedHours: z.number().positive().optional(),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Validation Patterns

### Input Validation Schemas
```typescript
// Separate schemas for different operations
const CreateTaskSchema = TaskSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

const UpdateTaskSchema = CreateTaskSchema.partial(); // All fields optional

const TaskQuerySchema = z.object({
  title: z.string().optional(),
  status: z.enum(["pending", "in_progress", "completed"]).optional(),
  priority: z.enum(["low", "medium", "high"]).optional(),
  projectId: z.string().optional(),
  tags: z.array(z.string()).optional(),
  dueDateFrom: z.string().optional().describe("Filter from due date (ISO string)"),
  dueDateTo: z.string().optional().describe("Filter to due date (ISO string)"),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
});

// Use in handlers
create: {
  description: "Create a new task",
  inputSchema: CreateTaskSchema,
  handler: async (data, user) => {
    // data is fully validated and typed
    const task = await createTask(data, user.id);
    return task;
  },
},

search: {
  description: "Search tasks with filters",
  inputSchema: TaskQuerySchema,
  handler: async (query, user) => {
    // query is validated with defaults applied
    return await searchTasks(query, user.id);
  },
}
```

### Advanced Validation
```typescript
const TaskSchema = z.object({
  id: z.string().readonly(),
  title: z.string()
    .min(1, "Title is required")
    .max(200, "Title must be less than 200 characters")
    .trim(),
  description: z.string()
    .max(2000, "Description must be less than 2000 characters")
    .optional(),
  status: z.enum(["pending", "in_progress", "completed"])
    .default("pending"),
  priority: z.enum(["low", "medium", "high"])
    .default("medium"),
  tags: z.array(z.string())
    .max(10, "Maximum 10 tags allowed")
    .transform(tags => tags.map(tag => tag.toLowerCase().trim())),
  dueDate: z.date()
    .min(new Date(), "Due date must be in the future")
    .optional(),
  estimatedHours: z.number()
    .positive("Estimated hours must be positive")
    .max(1000, "Estimated hours must be reasonable")
    .optional(),
  metadata: z.record(z.unknown()).optional(), // Flexible metadata
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});
```

## Schema Relationships

### Referential Integrity
```typescript
const ProjectSchema = z.object({
  id: z.string().readonly(),
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  status: z.enum(["active", "paused", "completed", "cancelled"]).default("active"),
  createdAt: z.date().readonly(),
});

const TaskSchema = z.object({
  id: z.string().readonly(),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  projectId: z.string().min(1, "Project is required"),
  status: z.enum(["pending", "in_progress", "completed"]).default("pending"),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

// Validate relationships exist
const validateTaskRelations = async (data: z.infer<typeof TaskSchema>) => {
  const project = await db.projects.findById(data.projectId);
  
  if (!project) throw new Error("Project not found");
  
  return { project };
};
```

### Polymorphic Relationships
```typescript
const AttachmentSchema = z.object({
  id: z.string().readonly(),
  filename: z.string().min(1, "Filename is required"),
  mimeType: z.string().min(1, "MIME type is required"),
  size: z.number().positive("File size must be positive"),
  url: z.string().url("Invalid URL"),
  entityType: z.enum(["task", "project", "note"]),
  entityId: z.string().min(1, "Entity ID is required"),
  createdAt: z.date().readonly(),
});

// Validate entity exists based on type
const validateAttachmentEntity = async (data: z.infer<typeof AttachmentSchema>) => {
  let entity;
  
  switch (data.entityType) {
    case "task":
      entity = await db.tasks.findById(data.entityId);
      break;
    case "project":
      entity = await db.projects.findById(data.entityId);
      break;
    case "note":
      entity = await db.notes.findById(data.entityId);
      break;
    default:
      throw new Error("Invalid entity type");
  }
  
  if (!entity) throw new Error(`${data.entityType} not found`);
  return entity;
};
```

## Schema Transformation and Coercion

### Data Transformation
```typescript
const TaskInputSchema = z.object({
  title: z.string().min(1).transform(title => title.trim()),
  description: z.string().optional().transform(desc => desc?.trim()),
  status: z.string().transform(str => str.toLowerCase()),
  priority: z.string().transform(str => str.toLowerCase()),
  tags: z.string().transform(str => str.split(',').map(tag => tag.trim())),
  dueDate: z.string().transform(str => new Date(str)), // Coerce string to Date
  estimatedHours: z.coerce.number().positive().max(1000), // Coerce string to number
});

// Use in handler
handler: async (rawData, user) => {
  // Transform and validate input
  const data = TaskInputSchema.parse(rawData);
  
  // data is now properly typed and transformed
  const task = await createTask(data, user.id);
  return task;
}
```

### Conditional Validation
```typescript
const TaskSchema = z.object({
  id: z.string().readonly(),
  title: z.string().min(1),
  description: z.string().optional(),
  status: z.enum(["pending", "in_progress", "completed"]),
  priority: z.enum(["low", "medium", "high"]),
  
  // Conditional fields based on status
  completedAt: z.date().optional().refine(
    (completedAt) => {
      // Completed tasks must have completion date
      return status !== "completed" || completedAt !== undefined;
    },
    { message: "Completed tasks require completion date" }
  ),
  
  // High priority tasks have additional requirements
  highPriority: z.object({
    reason: z.string().min(10, "High priority tasks require reason"),
    escalationContact: z.string().email("Invalid escalation contact email"),
    deadline: z.date().min(new Date(), "Deadline must be in the future"),
  }).optional().refine(
    (highPriority) => {
      return priority !== "high" || highPriority !== undefined;
    },
    { message: "High priority tasks require additional information" }
  ),
});
```

## Schema Composition and Reuse

### Base Schemas
```typescript
const BaseEntitySchema = z.object({
  id: z.string().readonly(),
  createdAt: z.date().readonly(),
  updatedAt: z.date().readonly(),
});

const AuditableSchema = BaseEntitySchema.extend({
  createdBy: z.string().min(1),
  updatedBy: z.string().min(1),
  version: z.number().positive(),
});

// Extend base schemas
const ProjectSchema = AuditableSchema.extend({
  name: z.string().min(1),
  description: z.string().optional(),
  status: z.enum(["active", "paused", "completed", "cancelled"]),
  // ... other project fields
});

const TaskSchema = AuditableSchema.extend({
  title: z.string().min(1),
  description: z.string().optional(),
  projectId: z.string().min(1),
  // ... other task fields
});
```

### Schema Merging
```typescript
const CreateTaskSchema = TaskSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  createdBy: true,
  updatedBy: true,
  version: true,
});

const UpdateTaskSchema = CreateTaskSchema.partial();

// Merge with additional validation
const CreateTaskWithValidationSchema = CreateTaskSchema.merge(
  z.object({
    confirmCreation: z.boolean().refine(
      (confirm) => confirm === true,
      { message: "Must confirm task creation" }
    ),
  })
);
```

## Best Practices

1. **Descriptive Error Messages**: Use clear, actionable error messages
2. **Schema Composition**: Build complex schemas from simple, reusable parts
3. **Input/Output Separation**: Use different schemas for input validation vs output
4. **Relationship Validation**: Always validate that referenced entities exist
5. **Type Safety**: Leverage TypeScript inference for compile-time safety
6. **Performance**: Use `.transform()` for expensive operations, `.refine()` for validation
7. **Documentation**: Use `.describe()` for AI agent understanding
8. **Default Values**: Provide sensible defaults where appropriate
9. **Coercion**: Use `.coerce` for safe type conversions
10. **Testing**: Test your schemas with various input scenarios
description: Zod schema design patterns and best practices for MCP servers
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---
description:
globs:
alwaysApply: false
---
